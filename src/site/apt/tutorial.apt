 --------
 Tutorial
 --------
 --------

Tutorial
~~~~~~~~
    This page describes all features of DbMaintain, and is organized into following parts:
	
	* {{{#Script_organization}Script organization}}
	
	  * {{{#Repeatable_scripts}Repeatable scripts}}
	  
	  * {{{#Postprocessing_scripts}Postprocessing cripts}}
	  
	  * {{{#Multi-database__user_support}Multi-database / user support}}
	  
	  * {{{#Patches}Patches}}
	  
	* {{{#Configure_and_run_DbMaintain}Configure and run DbMaintain}}
	  
	  * {{{#From_the_command line}From the command line}}
	  
	  * {{{#Using_ant}Using ant}}
	  
	  * {{{#From_Java_code}From Java code}}
	  
	* {{{#DbMaintain_operations}DbMaintain operations}}
	
* {Script organization}
~~~~~~~~~~~~~~~~~~~~~~~~
    Database scripts have to be organized in a folder structure, like demonstrated in following example:
	
+----+
scripts/01_v1.0/01_products_and_orders.sql
                02_users.sql
		02_v1.1/01_add_barcode_column.sql
		        02_drop_itemcode_column.sql
+----+
    Folder and script names must start with an index number followed by an underscore and a description. The index indicates the sequence of the scripts or script folders.

    Suppose you add a new script called <03_add_productid_sequence.sql>. The next time you call the <update-db> action, the database is updated incrementally by executing this new script. Unless you use the option <dbMaintainer.fromScratch.enabled>, updating an already executed incremental script is not allowed: the update action will fail if you try to do so. If <dbMaintainer.fromScratch.enabled> is set to true and an existing incremental script is changed, the database is cleared and all scripts are executed again.
	
** {Repeatable scripts}
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    The database scripts from the example above are incremental: each script contains a <delta>, and must be executed only once in the proper sequence. But DbMaintain also supports repeatable scripts: A repeatable script is written in such a way that it can be executed multiple times. For example, function or stored procedure defitions and views can be organized as repeatable scripts. The advantage of a repeatable script is that it can be modified: The script is simply executed again when changed. 
	
	You can recognize repeatable scripts from the file name: it has no index number. The directories that contain repeatable scripts also cannot have an index number. If you put a non-indexed script inside an indexed one, dbmaintain will give an error.
	
	If your database project contains repeatable scripts, it's a good idea to clearly separate them from the incremental scripts, like in following example:
	
+----+
scripts/incremental/01_v1.0/01_products_and_orders.sql
                            02_users.sql
		            02_v1.1/01_add_barcode_column.sql
		                    02_drop_itemcode_column.sql
		repeatable/proc_purge_old_orders.sql
		           proc_refresh_materialized_views.sql
+----+

	
** {Postprocessing scripts}
~~~~~~~~~~~~~~~~~~~~~~~~~~~
    Some projects have scripts that need to be executed each time something changed, like for example a script that compiles all stored procedures. Post processing scripts can be defined for this purpose. Post processing scripts have to be stored in the directory postprocessing, located directly in the root of the configured scripts folder. For example:
	
+----+
scripts/incremental/01_v1.0/01_products_and_orders.sql
                            02_users.sql
		            02_v1.1/01_add_barcode_column.sql
		                    02_drop_itemcode_column.sql
		repeatable/proc_purge_old_orders.sql
		           proc_disactivate_inactive_users.sql
		postprocessing/01_compile_all.sql
		               02_grant_select_to_read_user.sql
+----+

** {Multi-database / user support}
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    On some projects, database scripts need to be executed using different database connections. For instance, if your database consists of multiple schemas and you need to log in with a different user in order to perform modifications in another schema. 
	
	You can configure multiple databases, each of them identified with a different logical name. This logical is added to the script name after the script index, seperated from it with an underscore. If the script name doesn't indicate a target database, it will be executed on the default database.
	
	For example, suppose we have a second schema called <USERS>, and we have to login with a different user to be to create or alter tables. We have configured a second database connection identified by the logical name <users>. The scripts 02_users.sql and proc_disactivate_inactive_users.sql have to be executed with this other user:
	
+----+
scripts/incremental/01_v1.0/01_products_and_orders.sql
                            02_@users_users.sql
		            02_v1.1/01_add_barcode_column.sql
		                    02_drop_itemcode_column.sql
		repeatable/proc_purge_old_orders.sql
		           @users_proc_disactivate_inactive_users.sql
		postprocessing/01_compile_all.sql
		               02_grant_select_to_read_user.sql
+----+

** {Patches}
~~~~~~~~~~~~
    Because of the incremental nature of database updates, newly added scripts always have to come last: If a script is added with an lower index number than one that has already been executed, DbMaintain will give an error (or recreate the database from scratch if this option is enabled). 
	
	However it sometimes occurs that, while a new version of an application is being developed, an existing release of the application has to be patched, and this patch involves an incremental database change. In this case, a new incremental script must be created that precedes the scripts from the current development version. 
	
	For example: Suppose that our current production version is v1.0, and we're developing version 1.1. A fix must be applied in production that involves a database change: for this we created the script 03_add_product_status.sql. This fix is also merged into our current development branch, which leads us to the following sequence of scripts:
	
+----+
scripts/incremental/01_v1.0/01_products_and_orders.sql
                            02_@users_users.sql
							03_add_product_status.sql
		            02_v1.1/01_add_barcode_column.sql
		                    02_drop_itemcode_column.sql
+----+

    When we try to deploy to a test database on which the scripts in folder 02_v1.1 were already rolled out, DbMaintain will give an error. If the <fromScratch> option is enabled, the database will automatically be recreated from scratch. This will cause all data to be lost, which is in most cases not desirable: the database may be used by the customer to test the newly developed features.
	
	To be able cope with such situations, we offer the notion of a <patch>. A script or a folder containing scripts can be marked as being a <patch>, by adding the #PATCH qualifier to the file or folder name. A patch has to be written in such way that it can be executed on both the current production version and the latest development version. This will lead to the following scripts:
	
+----+
scripts/incremental/01_v1.0/01_products_and_orders.sql
                            02_@users_users.sql
							03_#PATCH_add_product_status.sql
		            02_v1.1/01_add_barcode_column.sql
		                    02_drop_itemcode_column.sql
+----+
	
	DbMaintain offers an option called <dbMaintainer.patch.outOfSequenceExecutionAllowed>. If set to <true>, DbMaintain will start with executing all patch scripts that weren't executed yet, before executing the other scripts. Note that you should never enable this option when deploying the production database!
	
* Configure and run DbMaintain
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     DbMaintain operations can be executed in various ways: from the command line, using ant or directly from Java code. In the 1.1 release, maven integration will be provided.
	 
** From the command line
~~~~~~~~~~~~~~~~~~~~~~~~
    Launch scripts are provided for Windows and *nix to perform operations from the command line. For instance, to create a jar file containing all scripts simply call (Replace .sh by .bat if you're using windows):

+-----+	 
/path/to/dbmaintain/dbmaintain.sh createJar path/to/jarFile path/to/scriptFolder
+-----+
	 
	To bring a database up-to-date, execute following command:
	 
+-----+	 
/path/to/dbmaintain/dbmaintain.sh update path/to/scriptFolderOrJarFile
+-----+

    If a file named dbmaintain.properties is available in the execution directory, this file is automatically loaded. To load another file, add -config path/to/configFile to the command.
	 
** Using ant
~~~~~~~~~~~~
    Ant tasks are provided for all DbMaintain operations. To be able to use these tasks, you have to declare them in your build file, e.g. as follows:
	 
+-----+
<taskdef resource="dbmaintain-anttasks.xml" classpathref="dbmaintain.lib"/>
<path id="dbmaintain-lib"><fileset dir="${dbmaintain.home}/lib"><include name="*.jar"/></fileset></path>
+-----+

    You can perform a database update with the following task.
	 
+-----+
<updateDatabase scriptLocations="${database.jarFile}">
     <database userName="admin" password="pwd" url="jdbc:hsqldb:mem:mydb" schemaNames="PUBLIC" dialect="hsqldb" driverClassName="org.hsqldb.jdbcDriver" />
</updateDatabase>
+-----+

    For an overview of all ant tasks with all their attributes, refer to the {{{ant-tasks.html}ant tasks}} page.

** From java code
~~~~~~~~~~~~~~~~~
    To launch DbMaintain operations from Java code, first create an instance of <org.dbmaintain.launch.DbMaintain>:
	
+-----+
URL configurationUrl = new File("dbmaintain.properties").toURI().toURL();
DbMaintain dbMaintain = new DbMaintain(configurationUrl);
+-----+

    To perform a database update simply call:
	
+-----+
dbMaintain.updateDatabase();
+-----+
	 
** Configuration
~~~~~~~~~~~~~~~~
     If you use the command line, you have to create a properties file that configures the target database and a number of extra options. Go to the {{{configuration.html}configuration page}} for a listing of all configuration options.
	 
	 If you run DbMaintain from the command line, you have to use a properties file for configuration. If you use ant, the most common configuration can be performed using attributes from the ant tasks. To configure less common options, you can still refer to a properties file from within the ant task using the <configFile> attribute.
	 
* DbMaintain operations
~~~~~~~~~~~~~~~~~~~~~~~
    Whether you launch DbMaintain from the command line, using ant or directly from Java code, the same set of operations is exposed:
	
** Create a jar file
~~~~~~~~~~~~~~~~~~~~
    The simplest way to use DbMaintain is to simply configure it with a scripts folder. However, it's a good idea to package the scripts is a jar file to be able to publish it as an artifact, just as you typically publish your war or ear file as an artifact. You can configure ...